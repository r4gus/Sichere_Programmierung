\documentclass[12pt]{article}
\parindent0em
\parskip 1ex plus 0.4ex minus 0.4ex

\usepackage[a4paper,vmargin=30mm,hmargin=25mm]{geometry}
\usepackage{polyglossia}
\setdefaultlanguage{german}
\usepackage{fontspec}
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}
\definecolor{lstbackground}{rgb}{0.95,0.95,1}      % hellgruener Rahmen
\lstset{language=Python}

\lstset{
  basicstyle=\small\ttfamily,
  backgroundcolor=\color{lstbackground},
  keywordstyle=\bfseries\ttfamily\color{blue},
  stringstyle=\color{orange!50!black}\ttfamily,
  commentstyle=\color{gray}\ttfamily,
  showstringspaces=false,
  flexiblecolumns=false,
  tabsize=4,
  numbers=left,
  numberstyle=\tiny,
  numberblanklines=true,
  stepnumber=1,
  numbersep=10pt,
  xleftmargin=15pt,
  literate=%
  {Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}1
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
  {~}{{\textasciitilde}}1
}

\begin{document}

\begin{center}
  \textbf{\LARGE Sichere Programmierung} \\[1ex]%
  \textbf{\Large Projekt 4}\\[2ex] %
  David Pierre Sugar\\ %
  (76050) \\ %
  Julian Sobott\\ %
  (76511) \\ %
  
\end{center}

\tableofcontents

% ****************************************************************************
\section{Einleitung}
% ****************************************************************************
In diesem Praktikum geht es darum Konzepte, die in der Vorlesung \textit{Einführung in die IT-Sicherheit} erklärt wurden, in Java zu implementieren. Hierzu wird die Kryptographie-API von Java verwendet.

% ****************************************************************************
\section{Aufgabe 1: Kryptographische Hashfunktion}
% ****************************************************************************

In dieser Aufgabe soll die Erzeugung und Verifikation einer Prüfsumme implementiert werden. Als Hashalgorithmus soll hier \texttt{SHA-256} verwendet werden.
Für die Aufgabe wurden zwei statische Methoden implementiert. \texttt{public static byte[] createChecksum(String message)} und \texttt{public static boolean verifyChecksum(byte[] checksum, String message)}. Die erste erzeugt eine Prüfsumme und die zweite verifiziert ob ein String dieselbe Prüfsumme erzeugt.

Fürs Erzeugen wird eine \texttt{MessageDigest} Instanz, welche mit \texttt{SHA-256} arbeitet, geholt. Mit dieser wird dann, der String in einen entsprechenden Hash Wert umgewandelt.

Fürs Verifizieren, wird auf dieselbe Weise von dem neuen String die Checksum erstellt. Ob die beiden gleich sind, wird mit der statischen Methode \texttt{MessageGigest.isEqual()} überprüft.

Zur demosntration der beiden Methoden, wurden in der \texttt{main} Methode 2 Strings erstellt. Die Verifikation gibt true zurück, wenn beide Strings gleich sind und false, wenn sie unterschiedlich sind.


% ****************************************************************************
\section{Aufgabe 2: Symmetrische Verschlüsselung}
% ****************************************************************************
Symmetrische Verschlüsselung ist ein Weg, Nachrichten vor unerwünschten
Einblicken zu schützen. Symmetrisch heißt dabei, dass der selbe Key zum ver-/
und wieder endschlüsseln verwendet wird. Ein Beispiel hierfür wäre der \texttt{AES}
(Advanced Encryption Standard) Algorithmus, der auch \texttt{Rijndael}
Algorithmus genannt wird, in Anlehnung an die Erfinder Vincent Rijmen und Joan
Daemen. Symmetrische Verschlüsselungen bieten, einen angemessen großen Key
vorrausgesetzt, guten Schutz und eine schnelle Ver-/ Entschlüsselung, 
jedoch muss zur sicheren Übermittlung auf andere
Verschlüsselungsverfahren wie RSA zurückgegriffen werden, da diese sonst leicht
von Dritten abgegriffen werden können.

\subsection{Cipher}
Der AES ist ein Block Cipher, d.h. es werden jeweils Blöcke zu je \texttt{128 Bit}
verschlüsselt, dabei werden die \texttt{Key-Längen 128, 192 und 256 Bit}
unterstützt. Die Länge des Keys gibt dabei die Anzahl an Transformationsrunden
vor, die für die Verschlüsselung durchlaufen werden. Um den Text wieder zu
entschlüsseln, werden die Runden rückwärts durchlaufen. Die Transformationen
finden dabei auf einer 4x4 Byte Matrix statt.

\subsection{Implementierung}
Das Beispiel besteht darin, einen String zu verschlüsseln, den Cipher Text auf
Standard Out auszugeben, den Cipher Text wieder zu entschlüsseln und auch den
entschlüsselten Text auf der Kommandozeile auszugeben. Sollte schlussendlich der
anfangs verschlüsselte Text richtig ausgegeben werden, so kann davon ausgeganen werden,
dass die symmetrische Verschlüsselung mittels AES richtig ausgeführt wurde.

\subsubsection{Key erstellen}
Als erstes wird ein zufälliger Key erstellt, der dann zusammen mit dem AES
Cipher verwendet werden soll. Dafür wird die Methode \texttt{getAESKey()}
aufgerufen, die einen \texttt{AES Key Generator} instanziert und danach mittels
\texttt{init()} diesen Key Generator mit einer Key Größe von 256 initialisiert.
Danach wird mit \texttt{generateKey()} der zufällige Key erstellt und zurück
gegeben.

\begin{lstlisting}
SecretKey key = getAESKey();
\end{lstlisting}

\subsubsection{Initialisierungs-Vektor}
Ein Initialisierungsvektor ist eine Zufallszahl, die als weitere Sicherheit in
die Verschlüsselung mit eingebracht wird. Um das Brechen des Ciphers,
z.B. mittels Dictionary Attack, zu
erschweren wird der vorrausgegangene Cipher Block mit genutzt, um den derzeitigen
Plaintext Block zu verschlüsseln. Da für den ersten Plaintext Block noch kein
Cipher Block zur verfügung steht, der verwendet werden kann wird eine
Zufallszahl, der IV, zur Verschlüsselung hinzugezogen.

Dieser IV wird von \texttt{getIvSpec()} zurückgegeben. 

\begin{lstlisting}
IvParameterSpec ivSpec = getIvSpec();
\end{lstlisting}

Dabei nutzt die Methode
einen Pseudo-Zufallszahl-Generator um ein Byte Array zu befüllen. Dieses Array
wird dann als Argument genutzt, um mit \texttt{IvParameterSpec()} ein IV Objekt
zu erzeugen.

\subsubsection{Cipher}
Um den Cipher zu initialisieren, wurde die Methode \texttt{initCipher()}
implementiert. Dies erhällt \texttt{Key} und \texttt{IV}, sowie den Modus
(ENCRYPT, DECRYPT) als Parameter und instanziert ein AES Cipher Objekt, das dann zur
verschlüsselung verwendet werden kann.

\begin{lstlisting}
Cipher cipher = initCipher(key, Cipher.ENCRYPT_MODE, ivSpec);
\end{lstlisting}

\subsection{Verschlüsselung}
Mittels \texttt{encrypt()} kann nun der Plain Text verschlüsselt werden. Dazu
werden Cipher sowie Text and die Methode übergeben, zurück kommt der Cipher Text
als Byte Array. Intern wird einfach nur \texttt{doFinal()} auf dem Cipher Objekt
aufgerufen.

\begin{lstlisting}
byte cipherText[] = encrypt(cipher, pt);
\end{lstlisting}

\subsubsection{Ausgabe Cipher Text}
Die Methode \texttt{printCipherText()} erhällte das Byte Array als Argument und
gibt es in \texttt{Base 64} codiert auf der Kommandozeile aus.

\begin{lstlisting}
printCipherText(cipherText);
\end{lstlisting}

\subsubsection{Entschlüsselung}
Nun muss der Text wieder entschlüsselt werden. Dazu wird das Cipher Objekt nun
mit dem \texttt{DECRYPT} Mode initialisiert, dabei bleiben Key und IV die
selben. Danach wird \texttt{decrypt()} aufgerufen. Die Methode ruft erneut
\texttt{doFinal()} auf und entschlüsselt damit den übergebenen Cipher Text,
zurück in den Ausgangstext.

\begin{lstlisting}
cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);
String new_pt = decrypt(cipher, cipherText);
\end{lstlisting}

\subsubsection{Ausgabe Plain Text}
Schlussendlich wird nun auch der entschlüsselte Plain Text auf der Kommandozeile
ausgegeben.

\begin{lstlisting}
System.out.println("Plain Text: " + new_pt); 
\end{lstlisting}

\subsection{Beispielausgabe}

\begin{lstlisting}
[sugar@jellyfish Code]$ java SymEncrypt 
Cipher Text: lPSGD5vFeGS7KlTBZjX2RQ==
Plain Text: Neo... Wake up!
[sugar@jellyfish Code]$ java SymEncrypt 
Cipher Text: OG5fVtza0u6P5RybQLLMGA==
Plain Text: Neo... Wake up!
[sugar@jellyfish Code]$ java SymEncrypt 
Cipher Text: +wCZzQ9bfxIA9r1aGFjB8Q==
Plain Text: Neo... Wake up!
\end{lstlisting}


% ****************************************************************************
\section{Aufgabe 3 Asymmetrische Verschlüsselung}
% ****************************************************************************
Diese Aufgabe soll die Nutzung des \texttt{RSA} Algorithmus für die asymmetrische Verschlüsselung zeigen. Ein Text soll mit einem public key verschlüsselt werden, und mit dem entsprechendem private key wieder entschlüssselt werden.

Hierzu wird als erstes mithilfe eines \texttt{KeyPairGenerator} ein Schlüsselpaar für die Verschlüsselung mit RSA erstellt. Auf die beiden Schlüssel kann dann mithilfe von gettern zugegriffen werden.

Als nächstes wird ein Objekt, welches für die Ver- und Entschlüsselung verantwortlich ist, mithilfe der factory Methode \texttt{getInstance} geholt. Dieses kann mehrmal verwendet werden, muss aber vor jeder Verwendung initialisiert werden. Hierbei muss übergeben werden, ob ver- oder entschlüsselt werden soll, und der jeweilige passende key. 
Mit der \texttt{doFinal} Methode, kann dann der ver-/entschlüsselungs Prozess abgeschlossen werden. Hierbei wird immer ein \texttt{byte[]} zurückgegebn, welches den Text enthält. 
Um den verschlüsselten Text schöner auf der Konsole anzuzeigen, wird er noch in Base64 umgewandelt. Außerdem wird das \texttt{byte[]} an den Konstruktor der Klasse \texttt{String} übergeben, um den Text als zusammenhängenden Text und nicht als Array auszugeben.

% ****************************************************************************
\section{Aufgabe 4: Digitale Signatur}
% ****************************************************************************



\end{document}



%%% Local Variables: 
%%% TeX-PDF-mode: t
%%% TeX-master: t
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End: 
