\documentclass[12pt]{article}
\parindent0em
\parskip 1ex plus 0.4ex minus 0.4ex

\usepackage[a4paper,vmargin=30mm,hmargin=25mm]{geometry}
\usepackage{polyglossia}
\setdefaultlanguage{german}
\usepackage{caption}
\usepackage{fontspec}
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{amsfonts}

\definecolor{lstbackground}{rgb}{0.95,0.95,1}      % hellgruener Rahmen
\lstset{language=C}

\lstset{
  basicstyle=\small\ttfamily,
  backgroundcolor=\color{lstbackground},
  keywordstyle=\bfseries\ttfamily\color{blue},
  stringstyle=\color{orange!50!black}\ttfamily,
  commentstyle=\color{gray}\ttfamily,
  showstringspaces=false,
  flexiblecolumns=false,
  tabsize=4,
  numbers=left,
  numberstyle=\tiny,
  numberblanklines=true,
  stepnumber=1,
  numbersep=10pt,
  xleftmargin=15pt,
  literate=%
  {Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}1
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
  {~}{{\textasciitilde}}1
}

\begin{document}

\begin{center}
  \textbf{\LARGE Sichere Programmierung} \\[1ex]%
  \textbf{\Large Projekt 2}\\[2ex] %
  Julian Sobott \\ %
  (76511) \\ %
  David Sugar \\ %
  (76050) \\ %
  
\end{center}

\newpage
\tableofcontents
\newpage

% ****************************************************************************
\section{Zu Aufgabe 1}
% ****************************************************************************
\subsection{a)}
Zu beginn der \texttt{main()} Funktion wird eine \texttt{unsigned int} Variable, i, deklariert, jedoch nicht initialisiert, d.h. bis auf wenige Ausnahmen $i \in \{0..2^{32}-1\}$.

Danach wird die Variable im Kopf der darauf folgenden For-Schleife mit 0 initialisiert. Die Schleife inkrementiert die Variable i am Ende jedes Schleifendurchlaufs und tritt erneut in die Schleife ein, solange i kleiner 20 ist.
Innerhalb der Schleife wird der Wert von i, zum jeweiligen Zeitpunkt, formatiert mithilfe von \texttt{printf()} in der Standardausgabe ausgegeben. Dabei werden immer 2 Stellen ausgegeben, dies wird über \texttt{"\%2d"} realisiert.

\textbf{Potentielles Problem: Es sollte \texttt{"\%2u"} verwendet werden, da \texttt{d} für die Formatierung von signed Integern verwendet wird.} In diesem Fall spielt die Formatierung aber keine Rolle.

\subsection{b)}
Bild \ref{fig:aufgabe1b} zeigt die Ausgabe des Programms.
\begin{figure}[h]
	\includegraphics[scale=0.9]{Pictures/aufgabe1b.png}
	\caption{Ausgabe von gdb-uebung-1.c}
	\label{fig:aufgabe1b}
\end{figure}

\subsection{c)}
\begin{lstlisting}
	<+8>:	mov    DWORD PTR [rbp-0x4],0x0
    <+15>:	jmp    0x40113b <main+41>
    <+17>:	mov    eax,DWORD PTR [rbp-0x4]
    <+20>:	mov    esi,eax
    <+22>:	mov    edi,0x402004
    <+27>:	mov    eax,0x0
    <+32>:	call   0x401030 <printf@plt>
    <+37>:	add    DWORD PTR [rbp-0x4],0x1
    <+41>:	cmp    DWORD PTR [rbp-0x4],0x13
    <+45>:	jbe    0x401123 <main+17>
\end{lstlisting}

Für die Variable i wird Speicher auf dem Stack alloziert, die Anfangsadresse ist dabei \texttt{rbp-0x4}.

In Zeile <+8> wird i mit 0x0 initialisiert. Danach springt das Programm unbedingt in Zeile <+41>. Hier befindet sich nun die Überprüfung, ob die Schleife verlassen wird, d.h. $ i \ge 0x14 $, oder ein weiterer Schleifendurchlauf gestartet wird. Dazu wird in Zeile <+41> i mit 0x13 verglichen. Ist der Wert kleiner oder gleich 0x13 wird in Zeile <+17> gesprungen und damit ein weiterer Schleifendurchlauf gestartet. Andernfalls wird die nächste Instruktion ausgeführt und damit die Schleife verlassen.

In Zeile <+17> und <+20> wird der Wert von i, vom Speicher in das \texttt{esi} Register geladen. In der darauf folgenden Zeile wird die Adresse des Formatierungsstrings ("i: \%2d\\n") ( 0x402004 ) in \texttt{edi} geladen.

\begin{lstlisting}
gef➤  x/s 0x402004
0x402004:	"i: %2d\n"
\end{lstlisting}

Weiterhin wird \texttt{eax} wieder auf 0x0 zurückgesetzt. Danach wird \texttt{printf()} mit den in \texttt{edi} und \texttt{esi} geladenen Parametern aufgerufen. Schlussendlich wird i inkrementiert und daraufhin wieder verglichen (<+41>).

\subsection{d)}

\newcommand{\imageseries}[1]{
\begin{center}
   \includegraphics[width=\textwidth]{Pictures/a1d_#1.png}
	\captionof{figure}{#1. Ausgabe von gdb-uebung-1.c}
\end{center}
%\begin{figure}[ht!]
%	\includegraphics[scale=0.5]{Pictures/a1d_#1.png}
%	\caption{#1. Ausgabe von gdb-uebung-1.c}
%	\label{fig:a1d_#1}
%\end{figure}
}

In dieser Aufgabe geht es nun darum das Programm \texttt{gdb-uebung-1.c} in gdb auszuführen. Im folgenden wird der Ablauf durch Screenshots und entsprechende Erklärungen beschrieben.

\imageseries{1}


1. Hier beginnt die \texttt{main} Funktion. Als erstes wird der \texttt{rsp} Zeiger, welcher auf den Stack zeigt, um \texttt{0x10} verschoben, um entprechen Platz auf den Stack zu allozieren.

\imageseries{2}

2. Initialisieren der Variable i  mit 0x0.

\imageseries{3}

3. Unbedingter Sprung in Zeile <main+41>.

\imageseries{4}

4. Ausgabe von i. (Adresse: Wert). Der Wert wird in Dezimal ausgegeben.

Schritte bis zur nächsten Zeile wurden übersprungen, da sie in Aufgabe 1 b) ausführlich erklärt wurden.

\imageseries{5}

5. Der bedinge Sprung \texttt{jbe} (jump below or equal) wird genommen, da $ 0x0 \le 0x13$. Das heißt, das Programm spring zu <main+17>.

\imageseries{6}

6. Schreiben des Wertes von i in eax und eax dann in esi, um i als Parameter an die \texttt{printf} Funktion zu übergeben.

\imageseries{7}
\imageseries{8}

7.+ 8. Aufrufen der \texttt{printf} Funktion mit i=0. Übergeben wird in rsi und rdi der Wert von i und ein pointer auf den format string. Dieser Aufruf führt zu folgender Ausgabe auf dem Standardoutput:

\begin{lstlisting}
i: 0
\end{lstlisting}

\imageseries{9}

9. Hier wird der Wert von i nun um eins erhöht.

\imageseries{10}

10. Nach der ausführung ist der Wert 1.

\imageseries{11}

11. Als nächstes wollen wir das Programm bis zum letzten Durchlauf laufen lassen und dort dann einen Breakpoint setzen. Als erstes geben wir uns hierfür die Adresse für i aus. Diese wird benötigt, da der Conditional Breakpoint nur stoppen soll, wenn i einen bestimmten Wert hat. In der nächsten Zeile setzen wir den Conditional Breakpoint in die Zeile wo der bedingte Sprung ist (<main+45>). Als Bedingung geben wir an, dass der Wert von i gleich 0x13 sein soll. Wie auch in C müssen Adressen jeweils mit dem * dereferenziert werden. Am Ende wird noch kontrolliert ob der breakpoint richtig gesetzt wurde.

\imageseries{12}

12. Lassen wir das Programm nun mit continue (c) laufen, sehen wir alle Schleifendurchläufe mit den entsprechenden Ausgaben. Die letzte Ausgabe ist 18 (0x12).

\imageseries{13}

13. Der bedingte Sprung wird ein letztes Mal genommen, da der Wert von i gleich 19 (0x13) ist.

\imageseries{14}

14. Die Schleife ist eine letztes Mal durchgelaufen wie erwartet und hat noch die 19 ausgegeben. Wenn wir nun aber an dem bedingten Sprung angkommen wird dier nicht mehr genommen, da die Bedingung nicht mehr zutrifft (i = 0x14 und somit glit nicht mehr i <= 0x13).

\imageseries{15}

15. Anstatt an <main+17> zu springen, wurde zur nächsten Anweisung gesprungen <main+47>. Somit wurde die Schleife verlassen. Hier wird noch die 0 als Rückgabewert gespeichert. 

\imageseries{16}

16. Mit continue (c) lassen wir das Programm zuende durchlaufen und es wird normal beendet.


% ****************************************************************************
\section{Zu Aufgabe 1}
% ****************************************************************************
\subsection{a)}

Anlyse des Programs \textit{gdb-uebung-2.c}

\lstinputlisting{../gdb-uebung-2.c}

Das Programm besteht aus drei Hilfsfunktionen \texttt{f}, \texttt{g}, \texttt{h}, die jeweils 2 int's als Eingabe bekommen und mit Grundrechenarten ein Ergebnis berechnen und zurück geben. Die Berechnungen scheinen willkürlich sein. 

In der \texttt{main} Funcktion, werden zuerst drei int's \texttt{a, b, c} initialisiert werden. Daraufhin wird in einem geschachtelten Funktionsaufruf der Wert von \texttt{c} berechnet. In den Funktionsaufrufen, werden die Rückgabewerte einer Hilfsfunktion immer direkt an die nächste Funktion, als Parameter, übergeben. Am Ende wird durch ein Aufruf der \texttt{printf} Funktion ein formatierter String mit den Werten von den Variablen ausgegeben.


\subsection{b)}

Bild \ref{fig:aufgabe2b} zeigt die Ausgabe des Programms.
\begin{figure}[h!]
	\includegraphics[width=\textwidth]{Pictures/a2b.png}
	\caption{Ausgabe von gdb-uebung-2.c}
	\label{fig:aufgabe2b}
\end{figure}


Wie erwartet sind die Werte von \texttt{a, b} unverändert zur ursprünglichen Initialisierung. Nur \texttt{c} hat den den neuen Wert, den es zugewiesen bekommen hat.

\subsection{c)}

\subsubsection{Reihenfolge der Funktionsaufrufe}

Die Reihenfolge wurde herausgefunden, indem in gdb mit s immer der nächste Schritt ausgeführt wurde. Hierfür wurde das Programm mit Debug Informationen compiliert (Option -g bei gcc).


\begin{enumerate}
\item \texttt{h(9, 5)} (2. h)
\item \texttt{h(5, 9)} (1. h)
\item \texttt{g(5, 314)}
\item \texttt{f(-692, 314)}
\end{enumerate}

Interessant bei der Ausführung ist, dass bei dem Aufruf von \texttt{f} zuerst der 2. Parameter (\texttt{h} )ausgewertet wird und dann erst der 1. (\texttt{g}).

Stack Frames: TODO

https://stackoverflow.com/questions/2770889/how-can-i-examine-the-stack-frame-with-gdb


For the current stack frame:

    info frame lists general info about the frame (where things start in memory, etc.)
    info args lists arguments to the function
    info locals lists local variables stored in the frame



















\newpage
% ****************************************************************************
\section{Zu Aufgabe 3}
% ****************************************************************************
\subsection{a) Analysieren Sie den in der Datei enthaltenen Source Code}
Das bereitgestellte Quelldatei \texttt{gdb-uebung-3.c} enthält die rekursive Implementierung eines \textbf{Factorial-Algorithmus}, damit ist $f(n) = n! $.

\textbf{Def:} $ n! = n * (n-1) * (n-2) * ... * 1 = \prod_{i = 1}^{n} i ,\;  n \in \mathbb{N} $

\subsubsection{Implementierung}
\begin{figure}[h]
\begin{lstlisting}
unsigned int f(unsigned int i) {
  if (i>1) {
    return i * f(i-1);
  } else {
    return 1;
  }
}
\end{lstlisting}
\label{fig:factorial}
\caption{factorial function}
\end{figure}

Die Funktion, abgebildet in \ref{fig:factorial} nimmt einen vorzeichenlosen Integer als Argument und gibt als Ergebnis ebenfalls einen vorzeichenlosen Integer zurück. Dabei ist \textbf{int} jedoch betriebssystemabhängig definiert. Für die meisten Systeme kann jedoch angenommen werden, dass es sich dabei um ein \textbf{4 Byte} großes Wort handelt, d.h für den Rückgabewert kommen Werte innerhalb des Wertebereichs $  W = [0,2^{32}-1] $ in Frage. Aufgrund des extrem schnellen Wachstums von $ n! $ ist dies ein sehr beschränkender Faktor, der bei der Nutzung unbedingt mit zu berücksichtigen ist, da es schnell zu einem Überlauf und damit zu einer Verfälschung des Ergebnisses kommen kann. In Zeile 2 wird danach geprüft, ob der übergebene Wert größer 1 ist. Sollte dies der Fall sein, wird das  Produkt von i und dem Ergebnis des Rekursiven Aufrufs von $ f(i-1) $ zurückgegeben. Andernfalls wird die Konstante 1 als Rückgabewert der Funktion genutzt, siehe Zeile 5.
\newpage

\subsubsection{Aufruf}
\begin{figure}[h]
\begin{lstlisting}
int main() {
  unsigned int i=5, r=0;

  r = f(i);

  printf("i = %d, f(i) = %d\n", i, r);
}
\end{lstlisting}
\label{fig:factorial-main}
\caption{invocation of f()}
\end{figure}

In der \textbf{main()} Funktion wird die in \ref{fig:factorial} beschriebene Funktion \textbf{f(unsigned int)} aufgerufen und dabei \textbf{i = 5} als Argument übergeben. Das Ergebnis des Aufrufs wird der Variable \textbf{int r} zugewiesen, siehe Zeile 4. Danach wird \textbf{i} und das Ergebnis \textbf{r} mittels \textbf{printf()} auf der Kommandozeile ausgegeben.

\subsection{b) Kompilieren Sie den C Code und führen Sie das Programm aus }
\subsubsection{Kompilieren}
Das Kompilieren des Quellkodes innerhalb von \texttt{gdb-uebung-3.c} kann mittels des folgenden Befehls auf der Kommandozeile ausgeführt werden.
\begin{lstlisting}
$ gcc gdb-uebung-3.c -o gdb-uebung-3
\end{lstlisting}
Der in diesem Fall genutzte Compiler heißt \textbf{gcc} (GNU compiler collection). Dabei ist gdb-uebung-3.c der Name der Quelldatei. Mittels \textbf{-o gdb-uebung-3} wird der gewünschte Name, der zu erstellenden Programmdatei, angegeben.

\subsubsection{Ausführen}
Das Programm kann nun auf der Kommandozeile ausgeführt werden.
\begin{lstlisting}
$ ./gdb-uebung-3                    
i = 5, f(i) = 120
\end{lstlisting}
Zum verifizieren des Ergebnisses kann dieses auch noch einmal Händisch berechnet werden, $ \prod_{i = 1}^{5} i = 1 * 2 * 3 * 4 * 5 = 2 * 3 * 20 = 2 * 60 = 120 $. Das Ergebnis stimmt, die Funktionen scheint auf den ersten Blick also richtig implementiert. Um nachzuvollziehen, wie die das Ergebnis zustande kommt, kann der folgende Graph betrachtet werden.

\begin{center}
\begin{figure}[h]
	\includegraphics[scale=0.6]{Pictures/aufgabe3aufrufe.pdf}
	\caption{recursive call of f()}
	\label{fig:recursive2}
\end{figure}
\end{center}

Anfangs wird in \textbf{main()} die Funktion \textbf{f()} mit \textbf{5 als Argument} aufgerufen. Die aufgerufene Funktion f(5) prüft nun, ob der Parameter größer als 1, d.h. \textbf{5 > 1}, ist. Ist dies der Fall, ruft sich die Funktion selbst wieder auf, dieses Mal jedoch mit dem \textbf{dekrementierten} Parameter als Argument. Dies wiederholt sich bis 1 bzw. 0 übergeben wird, in diesem Fall wird 1 zurückgegeben und das Ergebnis 'aufsteigend' berechnet.

\subsection{c) Führen Sie das Programm im GDB aus}




\subsubsection{Wie viele Stack Frames werden erzeugt?}

\subsubsection{Wie ist der Inhalt dieser Stack Frames?}

\subsubsection{Wie wird die Parameterübergabe in Assembler umgesetzt?}
Für die Übergabe von Parametern an Subroutinen muss unter x86 eine Fallunterscheidung gemacht werden. Je nachdem, ob es sich um Programme für ältere 32-Bit Prozessoren handelt oder um Programme für neuere 64-Bit Prozessoren, werden verschiedene sog. \textbf{Calling Conventions} (Aufruf Konventionen) verwendet. Diese Konventionen dienen dazu einen Ablauf zu definieren, sodass unabhängig vom Autor des Codes darauf vertraut werden kann, dass Abläufe wie z.B. ein Unterprogrammaufruf \textbf{immer} auf die selbe Weise durchgeführt werden.

\subsubsection*{32-Bit}
Ein Unterprogrammaufruf kann in folgende Schritte untergliedert werden.
\begin{enumerate}
\item Zuerst müssen die \textbf{Caller Saved Register}, falls nötig, auf dem Stack gespeichert werden, da die \textbf{aufgerufene} Funktion für diese Register keine Garantie übernimmt, dass diese nicht überschrieben werden. Die Register sind: ebx, ecx, edx, r10, r11.
\item Danach müssen die Parameter in \textbf{umgekehrter Reihenfolge} auf den Stack gepushed werden. Aufgrund der Funktionsweise des Stacks ist dann der Erste Parameter der Subroutine direkt angrenzend and die gespeicherte Rücksprungadresse, die im nächsten Schritt auf dem Stack hinterlegt wird.
\item Nun wird mit \textbf{call} der Unterprogrammaufruf durchgeführt. Dabei wird die \textbf{Rücksprungadresse} (die Adresse des auf call folgenden Befehlswortes) auf den Stack gepushed und ein Sprung zum ersten Befehl des Unterprogramms, markiert durch das angegebene \textbf{Label}, gesprungen.
\item Die ersten Befehle des Unterprogramms bilden einen sog. \textbf{Function Prologue}. Hier wird als aller erstes der aktuelle Wert des \textbf{Base-Pointers (bp)} auf den Stack gepushed, sowie die \textbf{Callee-Saved Register} falls benötigt. Danach wird der Aktuelle Wert des \textbf{Stack-Pointers (sp)} genutzt um den für den derzeitigen \textbf{Stack-Frame} verantwortlichen bp zu initialisieren, indem sp in bp verschoben wird. Danach wird der sp mit \textbf{SUB} verringert um Speicher auf dem Stack für lokale Variablen zu allozieren.
\item Am Ende der Subroutine wird dann der sog. \textbf{Function Epilogue} ausgeführt. Hier werden falls vorhanden, die gesicherten Register gepoppt, zusammen ...
\end{enumerate}



\end{document}



%%% Local Variables: 
%%% TeX-PDF-mode: t
%%% TeX-master: t
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End: 
